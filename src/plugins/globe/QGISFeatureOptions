/* -*-c++-*- */
/*
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */
#ifndef OSGEARTH_DRIVER_QGIS_FEATURE_SOURCE_OPTIONS
#define OSGEARTH_DRIVER_QGIS_FEATURE_SOURCE_OPTIONS 1

#include <osgEarth/Common>
#include <osgEarthFeatures/FeatureSource>

class QgisInterface;
class QgsVectorLayer;

namespace osgEarth { namespace Drivers
{
  using namespace osgEarth;
  using namespace osgEarth::Features;
  
  class QGISFeatureOptions : public FeatureSourceOptions // NO EXPORT; header only
  {
  public:
    optional<std::string>& layerId() { return layerId_; }
    const optional<std::string>& layerId() const { return layerId_; }
    
    QgisInterface* qgis() { return qgis_; }
    void setQgis( QgisInterface* iface ) { qgis_ = iface; }

    QgsVectorLayer* layer() { return layer_; }
    void setLayer( QgsVectorLayer* layer ) { layer_ = layer; }
    
  public:
    QGISFeatureOptions( const ConfigOptions& opt = ConfigOptions() ) : FeatureSourceOptions( opt ) {
      // -> this is the important thing here
      // it will call the driver declared as "osgearth_feature_qgis"
      std::cout << "QGIS options CTOR" << std::endl;
      setDriver( "qgis" );
      fromConfig( _conf );
    }
    
  public:
    Config getConfig() const {
      std::cout << "QGIS options::getConfig" << std::endl;
      Config conf = FeatureSourceOptions::getConfig();
      conf.updateIfSet( "layerId", layerId_ );
      conf.update( "qgis", toString( qgis_ ) );
      conf.update( "layer", toString( layer_ ) );
      return conf;
    }
    
  protected:
    void mergeConfig( const Config& conf ) {
      FeatureSourceOptions::mergeConfig( conf );
      fromConfig( conf );
    }
    
  private:
    // !WARNING!
    // osg earth plugins seem to expect options passed either by a string
    // or by a referenced pointer.
    // Since we do not have any osg::referenced here and want to pass the QGisInterface pointer
    // we violently convert it to a string of its plain number representation.

    // convert a pointer to a string (!!)
    std::string toString( void* ptr ) const
    {
      char str[sizeof(void*)*2+1];
      sprintf( str, "%p", ptr );
      return std::string(str);
    }

    // convert back a string representing a pointer to a pointer (!!)
    void* toPointer( const std::string& sptr ) const
    {
      void* p;
      sscanf( sptr.c_str(), "%p", &p );
      return p;
    }

    void fromConfig( const Config& conf ) {
      conf.getIfSet( "layerId", layerId_ );
      qgis_ = reinterpret_cast<QgisInterface*>(toPointer( conf.value( "qgis" ) ));
      layer_ = reinterpret_cast<QgsVectorLayer*>(toPointer( conf.value( "layer" ) ));
    }
    
    optional<std::string>             layerId_;
    QgisInterface* qgis_;
    QgsVectorLayer* layer_;
  };
  
  } } // namespace osgEarth::Drivers

#endif // OSGEARTH_DRIVER_QGIS_FEATURE_SOURCE_OPTIONS

